
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Mnemnion</title>
  <meta name="author" content="Sam Atman">

  
  <meta name="description" content="Everyone, when they encounter Lisp for the first time, has trouble with the parentheses. It&#39;s a rite of passage. Everyone who goes on to learn &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://mnemnion.github.io/blog/page/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Mnemnion" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Mnemnion</a></h1>
  
    <h2>A Unit of Analogy</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:mnemnion.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/11/a-parenthetical-observation/">A Parenthetical Observation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-11T10:38:00-07:00" pubdate data-updated="true">Sep 11<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Everyone, when they encounter Lisp for the first time, has trouble with the parentheses. It&#39;s a rite of passage. </p>

<p>Everyone who goes on to learn Lisp develops a <em>very</em> different attitude. I&#39;d like to share an observation that helps understand why.</p>

<p>I write a fair amount of Lisp, in a few dialects. I could get that work done without a &quot;)&quot; key on my keyboard. </p>

<p>Lisp means never having to close your forms. The delimiters on the left are for you to read, the ones on the right are just a period. </p>

<p>I find it interesting that anathema accumulates around code barriers, rather than internal syntax. Semicolons, significant whitespace, brace placement, and parentheses have all been the subject of holy war, and one may easily find developers who simply refuse to work with certain separation styles unless pressed. At the moment I can&#39;t account for this observation, but I&#39;d like to note that I&#39;ve never seen a holy war over, say, <code>:=</code> vs <code>=</code> vs <code>&lt;-</code>. Perhaps I&#39;m not on the right mailing lists. </p>

<p>On the other hand, capitalization and underscore vs. slash vs. nothing are certainly capable of eating up arbitrary amounts of bad blood. Never underestimate the geek&#39;s capacity to bikeshed. </p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/04/why-i-am-lisp-2/">Why I Am Lisp 2</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-04T09:44:00-07:00" pubdate data-updated="true">Sep 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>First things first: Lisp 1 and Lisp 2 are the worst sort of jargon, because they mean exactly nothing without explanation. Renaming them is even worse.</p>

<p>I&#39;ve done this kind of bad abstracting before, in public even. Be careful when naming things. Nouns are sticky.</p>

<p>For those who don&#39;t speak Boston Yiddish, Lisp 1 means that symbols and functions share a namespace. In Lisp 2, they do not. Simple as that.</p>

<p>Of the Big Four, Clojure and Scheme are Lisp 1. Common Lisp and Emacs Lisp are Lisp 2. Yes, elisp is at least as important as the other three.</p>

<p>Having worked at this point with three of the four, Scheme excepted, I prefer Lisp 2. One simple reason: a function is linguistically a verb. If we don&#39;t make a separate namespace for &#39;variable&#39; uses of symbols, we can&#39;t have separate nouns and verbs. This is somewhat uncomfortable in practice.</p>

<p>Ultimately, I feel that this problem arises from a peculiarity of English: The standard way to verb a noun, in the third person (which is what is used for the imperative), involves no change whatsoever to the noun. If we have a list, we list it. There are hundreds of valid verbs which are letter-identical to a corresponding noun, and it is increasingly easy to create more. Thanks Joss Whedon! No, seriously, thanks, it fits English like a glove.</p>

<p>Contrast with a language like Spanish, where there are quite few verbs which cannot be letter distinguished from a noun. It&#39;s a shame computer language design is so heavily influenced by English. A Spanish programming language would be a pleasure to work with, and I can only begin to imagine the sophistication possible in an Arabic or Hebrew based programming language that makes clever use of the Semitic roots and mutations.</p>

<p>Meanwhile, back on this planet, we benefit from separate noun and verb slots in a symbol. <code>funcall</code> is a small price to pay.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/04/in-which-we-build-zeus/">In Which We Build Zeus</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-04T18:59:00-07:00" pubdate data-updated="true">Aug 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Athena is our weaver. This is her source file. </p>

<p>As we are writing a weaver, it happens that we do not have one. This file must perforce be hand woven until Athena may take over. Asking a Goddess to take over any process should not, and shall not, be done casually. </p>

<p>Athena is written in <a href="https://help.github.com/articles/github-flavored-markdown">Git Flavored Markdown</a>, a format designed around code sharing. The executable parts are written in <a href="http://clojure.org">Clojure</a>, using the <a href="https://github.com/Engelberg/instaparse">Instaparse</a> parsing library. </p>

<h1 id="toc_8">Hymn</h1>

<p>Hail, fleet footed Hermes, beloved of Athena!</p>

<p>Hail, Pallas Athene! Hear the ancient words:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>I begin to sing of Pallas Athena, the glorious Goddess, bright-eyed,  
</span><span class='line'>inventive, unbending of heart,  
</span><span class='line'>pure virgin, saviour of cities,  
</span><span class='line'>courageous, Tritogeneia. Wise Zeus himself bare her  
</span><span class='line'>from his awful head, arrayed in warlike arms  
</span><span class='line'>of flashing gold, and awe seized all the gods as they gazed.  
</span><span class='line'>But Athena sprang quickly from the immortal head 
</span><span class='line'>and stood before Zeus who holds the aegis,  
</span><span class='line'>shaking a sharp spear: great Olympus began to reel horribly 
</span><span class='line'>at the might of the bright-eyed Goddess, 
</span><span class='line'>and earth round about cried fearfully,  
</span><span class='line'>and the sea was moved and tossed with dark waves,  
</span><span class='line'>while foam burst forth suddenly:  
</span><span class='line'>the bright Son of Hyperion stopped his swift-footed horses a long while, 
</span><span class='line'>      until the maiden Pallas Athena had stripped the heavenly armour 
</span><span class='line'>      from her immortal shoulders.  
</span><span class='line'>And wise Zeus was glad. </span></code></pre></td></tr></table></div></figure>

<p>And so hail to you, daughter of Zeus who holds the aegis!<br><br>
Now I will remember you and another song as well.  </p>

<h2 id="toc_9">Bootstrap</h2>

<p>To bootstrap Athena, we write a restricted program. It does not weave, so much as extract and concatenate code.</p>

<p>We then write more Markdown that specifies a macro format, also in this restricted format. We use our first weaver to weave both generations of the project into Athena, which will then be more broadly useful. </p>

<p>This first weaver will be known as zeus. zeus is, of course, that from which Athena will spring full-born. </p>

<p>Clojure projects are typically generated with <a href="https://github.com/technomancy/leiningen">Leiningen</a>, and Athena is no exception. Leiningen projects are specified in a root directory file called <code>project.clj</code>. </p>

<p>This is project.clj:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defproject </span><span class="nv">athena</span> <span class="s">&quot;0.1.0-SNAPSHOT&quot;</span>
</span><span class='line'>  <span class="ss">:description</span> <span class="s">&quot;Athena: a Weaver of Code&quot;</span>
</span><span class='line'>  <span class="ss">:url</span> <span class="s">&quot;http://github.com/mnemnion/marmion/athena&quot;</span>
</span><span class='line'>  <span class="ss">:license</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;BSD 2-Clause License&quot;</span>
</span><span class='line'>            <span class="ss">:url</span> <span class="s">&quot;http://http://opensource.org/licenses/BSD-2-Clause&quot;</span><span class="p">}</span>
</span><span class='line'>  <span class="ss">:dependencies</span> <span class="p">[[</span><span class="nv">org.clojure/clojure</span> <span class="s">&quot;1.4.0&quot;</span><span class="p">]])</span>
</span></code></pre></td></tr></table></div></figure>

<p>In order to weave code, in general, we need a macro format. This may be made as flexible as necessary. The minimal requirement is the ability to specify a macro name, and expand those macros into files. </p>

<p>This is weaving in its essence.</p>

<p>The above code contains no macro, yet. Writing macros in a Lisp is of course pleasurable and powerful, and Clojure is no exception, having definable <a href="http://clojure.org/reader">reader macros</a>. Soon, we will define one.</p>

<p>First, however, we need a parser that can extract our code. For that, we need to add <a href="https://github.com/Engelberg/instaparse">Instaparse</a>.</p>

<p>Time to fire up <a href="https://github.com/bodil/catnip">Catnip</a> real quick. Be back soon!</p>

<p>What we&#39;re doing next is adding Instaparse to our project. To do this, we have to tell Leiningen to grab Instaparse, which we must do from the config file. This is normally found at <code>~/.lein/profiles.clj</code>; if it&#39;s not, I hope you know what you&#39;re doing. We add the string <code>[instaparse &quot;1.2.2&quot;]</code> to the <code>:plugins</code> vector.</p>

<p>That done, start or restart your project in Catnip, <a href="http://emacs.org">Emacs</a>, or however you like to do it. You must launch with <code>lein</code>, which is totally conventional.</p>

<p>This being a bootstrap, we will need to resort to some custom syntax in our Markdown. As we extract the source, we will encounter various <code>@magic words@</code>, which the parser will do various things with. The ones in this paragraph, for example, it will ignore. The recognition sequence is <code>`@</code> to begin a magic word, and <code>@`</code> to end one. </p>

<p>These aren&#39;t macros. As you can see, they remain in the source code, and don&#39;t modify it.</p>

<p>Adding <code>[instaparse &quot;1.2.2&quot;]</code> to our project.clj gives us this:</p>

<p><code>@/marmion/athena/project.clj@</code> &#8211;&gt; where we find it, natch</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defproject </span><span class="nv">athena</span> <span class="s">&quot;0.1.0-SNAPSHOT&quot;</span>
</span><span class='line'>  <span class="ss">:description</span> <span class="s">&quot;Athena: a Weaver of Code&quot;</span>
</span><span class='line'>  <span class="ss">:url</span> <span class="s">&quot;http://github.com/mnemnion/marmion/athena&quot;</span>
</span><span class='line'>  <span class="ss">:license</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;BSD 2-Clause License&quot;</span>
</span><span class='line'>            <span class="ss">:url</span> <span class="s">&quot;http://http://opensource.org/licenses/BSD-2-Clause&quot;</span><span class="p">}</span>
</span><span class='line'>  <span class="ss">:dependencies</span> <span class="p">[[</span><span class="nv">org.clojure/clojure</span> <span class="s">&quot;1.4.0&quot;</span><span class="p">]</span>
</span><span class='line'>                 <span class="p">[</span><span class="nv">instaparse</span> <span class="s">&quot;1.2.2&quot;</span><span class="p">]])</span>
</span></code></pre></td></tr></table></div></figure>

<p>Which should compile. </p>

<p>Lein provides us with the following template in <code>@/marmion/athena/src/athena/core.clj@</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">ns </span><span class="nv">athena.core</span>
</span><span class='line'>    <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">instaparse.core</span> <span class="ss">:as</span> <span class="nv">insta</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">foo</span>
</span><span class='line'>  <span class="s">&quot;I don&#39;t do a whole lot.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">println </span><span class="nv">x</span> <span class="s">&quot;Hello, World!&quot;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>

<p>We added instaparse.core there. This should compile too. </p>

<p>We now have a powerful and general [GLL] parser at our disposal. Yippie!</p>

<p>Let&#39;s do something with it!</p>

<p>How about we open up our source file, <code>athena.md</code>, and see if we can produce a quine of our existing file and directory structure?</p>

<p>Leiningen provides us with a test, <code>@/marmion/athena/src/athena/core_test.clj@</code>. It begins life looking like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">ns </span><span class="nv">athena.core-test</span>
</span><span class='line'>  <span class="p">(</span><span class="ss">:use</span> <span class="nv">clojure.test</span>
</span><span class='line'>        <span class="nv">athena.core</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">deftest</span> <span class="nv">a-test</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;FIXME, I fail.&quot;</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="mi">1</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>

<p>We will leave it alone for now. Eventually, we will want to test our quine against the code as it was written. </p>

<p>For the same reason, we will leave the function <code>foo</code> in the namespace. Nothing will be deleted or modified, and the order in which code is introduced is the order into which it will be woven. This is a bootstrap, after all. </p>

<p>Instaparse has its own format, which could be specified as a string within the .clj file. We prefer to put the grammar in its own file, <code>@/marmion/athena/zeus.grammar@</code>, which we start like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>(* A Grammar for Zeus, Father of Athena, A Literate Weaver *)
</span></code></pre></td></tr></table></div></figure>

<p>Our first rule is top level. The markdown may be separated into that which is kept, that which is ignored, and that which is magic.</p>

<p>In Instaparse, that looks something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>zeus-program = (magic | code | &lt;markdown&gt;) *
</span></code></pre></td></tr></table></div></figure>

<p>What this says is that a zeus program is any combination of magic, code, and markdown. Since Zeus does nothing with the markdown, we use angle brackets to tell Instaparse that we don&#39;t care to see the output. </p>

<p>We&#39;ll define code next:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>code =  &lt;&quot;`&quot; &quot;`&quot; &quot;`&quot;&gt; code-type code-block+ &lt;&quot;`&quot; &quot;`&quot; &quot;`&quot;&gt;
</span><span class='line'>   | &lt;&quot;`&quot; &quot;`&quot; &quot;`&quot;&gt; &quot;\n&quot; code-block+ &lt;&quot;`&quot; &quot;`&quot; &quot;`&quot;&gt;
</span><span class='line'>   ;
</span><span class='line'>
</span><span class='line'>code-type = &quot;clojure&quot; | &quot;text&quot; ;
</span><span class='line'>
</span><span class='line'>&lt;code-block&gt; = #&#39;[^`]+&#39; | in-line-code ;
</span><span class='line'>
</span><span class='line'>&lt;in-line-code&gt; = !(&quot;`&quot; &quot;`&quot; &quot;`&quot;) (&quot;`&quot;|&quot;``&quot;);
</span></code></pre></td></tr></table></div></figure>

<p>Which will suffice to capture our quine. </p>

<p>Please note: we could use a more direct way to capture three <code>`</code>, if we weren&#39;t writing a peculiar quine. Zeus uses the simplest possible grammar to extract a minimalist weaver from this very source file. </p>

<p>A couple notes: <code>code-block</code> is mostly a regular expression that doesn&#39;t consume backticks. <code>in-line-code</code> uses negative lookahead <code>!</code>, which is great stuff: it says, if there aren&#39;t three backticks ahead of us, you may match one or two of those backticks. </p>

<p>Between them, they match everything except three backticks. Real Markdown uses newlines and triple backticks together. This is harder to write and understand, so we&#39;ll do it in the second pass.</p>

<p>We also need magic:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>&lt;magic&gt; = &lt;&quot;`@&quot;&gt; magic-word &lt;&quot;@`&quot;&gt; ;
</span><span class='line'>
</span><span class='line'>magic-word = #&#39;[^@]+&#39; ;
</span></code></pre></td></tr></table></div></figure>

<p>Which is defined fairly carefully to consume our magic words. We don&#39;t use the at-sign elsewhere in the outer Markdown to enable easy magic.</p>

<p>That leaves <code>markdown</code> which is perhaps not strictly named, since the code blocks are markdown also. For Zeus, we may as well call it junk; we have to match it, but we don&#39;t look at it. It looks like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>markdown = #&#39;[^`@]+&#39; | in-line-code;
</span></code></pre></td></tr></table></div></figure>

<p>We&#39;re done! We now have a grammar that we can make into a parser, so let&#39;s do it: we need to add more code to <code>@/marmion/athena/src/athena/core.clj@</code>. </p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">zeus-parser</span> <span class="p">(</span><span class="nf">insta/parser</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;zeus.grammar&quot;</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>

<p>That was simple enough. It disguises the toil of repeatedly writing bad, useless and exponentially explosive grammars.</p>

<p>But then, literature generally hides the messiness behind its production. If you have read the unedited <em>Stranger in a Strange Land</em>, which Heinlein never wanted published, you can see why. Presuming you&#39;ve read the edited version. </p>

<p>Now, we use <code>zeus-parser</code> to parse this document, <code>athena.md</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">parsed-athena</span> <span class="p">(</span><span class="nf">zeus-parser</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;athena.md&quot;</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>

<p>When we run <code>core.clj</code> in a REPL, we see that <code>parsed-athena</code> is a tree-structure containing our magic words and code. We&#39;ve designed this puzzle so that we can use this sorted information in the order we found it, so we don&#39;t need the tree structure.</p>

<p>To simply get rid of the tree structure we would <code>flatten</code> it. But this would leave us in a bad way, because some of our code blocks aren&#39;t globbed into a single string, thanks to separate detection for <code>` `</code> [sic] and <code>`</code>. </p>

<p>Fortunately, this is so common that Instaparse ships with a function for fixing it. <code>insta/transform</code> to the rescue!</p>

<p>First we need a helper function for insta/transform to call:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">cat-code</span> <span class="s">&quot;a bit of help for code blocks&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">tag</span> <span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">[</span><span class="nv">tag</span> <span class="p">(</span><span class="nb">apply str </span><span class="nv">body</span><span class="p">)]))</span>
</span></code></pre></td></tr></table></div></figure>

<p>Then we call it and do some stuff to the results:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">flat-athena</span> <span class="p">(</span><span class="nb">drop </span><span class="mi">10</span> <span class="p">(</span><span class="nf">flatten</span> <span class="p">(</span><span class="nf">insta/transform</span> <span class="p">{</span><span class="ss">:code</span> <span class="nv">cat-code</span><span class="p">}</span> <span class="nv">parsed-athena</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>

<p>Now, how you feel about this line depends on how you feel about Lisp, generally. This was written progressively from the middle out, on a REPL. It&#39;s easy to read if you know that, and would be easier still if formatted more naturally. </p>

<p>A more idiomatic Clojure way to do all this would be to use a threading macro like <code>-&gt;&gt;</code> to thread the data structure through the transformations, instead of making all these global defs. Everything so far could be a single function, though it&#39;s sensible to put the parser in its own ref.</p>

<p><code>drop 10</code> just gets us past the front matter. We introduce our idioms before we use them, for a reason.</p>

<p>We now have a flat vector, containing all the information we need. We need to transform it into a data structure which may then be massaged and spat out as our original project and core files. </p>

<p>The quine could be completed with a trivial act, which we put in the margins: <code>(spit athene-as-is.md (remove-tags-flatten-and-concatenate (zeus-parser (slurp athena.md) :unhide :all)))</code>, which calls a function we needn&#39;t bother to write. All this does is parse athena.md, remove the tags, flatten the remaining literal values, which, because we used <code>:unhide :all</code>, was everything from our original source file. Cute, but not interesting enough to belong in the quine. Opening your source file, doing nothing interesting to it, and saving/printing it is generally a trivial quine, though if the convolutions you put the text through are hard enough to follow you will amuse someone at least.</p>

<p>Instead, let&#39;s write a little helper function, <code>key-maker</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">key-maker</span>
</span><span class='line'>  <span class="s">&quot;makes a keyword name from our file string&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">file-name</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">keyword </span> <span class="p">(</span><span class="nb">last </span><span class="p">(</span><span class="nf">clojure.string/split</span> <span class="nv">file-name</span> <span class="o">#</span><span class="s">&quot;/&quot;</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>

<p>This takes our fully-qualified filename, pulled from a magic word, and keywordizes it. The magic words are arranged so there&#39;s one each time zeus needs to change files.</p>

<p>Now for the meat of the matter. <code>weave-zeus</code> produces the source file to zeus from the markdown version of this very file. </p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">weave-zeus</span>
</span><span class='line'>  <span class="s">&quot;a weaver to generate our next iteration&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">state</span> <span class="nv">code</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">keyword? </span><span class="p">(</span><span class="nb">first </span><span class="nv">code</span><span class="p">))</span>
</span><span class='line'>      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="ss">:magic-word</span> <span class="p">(</span><span class="nb">first </span><span class="nv">code</span><span class="p">))</span>
</span><span class='line'>          <span class="p">(</span><span class="nf">weave-zeus</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">state</span>
</span><span class='line'>                             <span class="ss">:current-file</span>, <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">rest </span><span class="nv">code</span><span class="p">)))</span>
</span><span class='line'>                      <span class="p">(</span><span class="nb">drop </span><span class="mi">2</span> <span class="nv">code</span><span class="p">))</span>
</span><span class='line'>          <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">file-key</span> <span class="p">(</span><span class="nf">key-maker</span> <span class="p">(</span><span class="ss">:current-file</span> <span class="nv">state</span><span class="p">))]</span>
</span><span class='line'>              <span class="p">(</span><span class="nf">weave-zeus</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">state</span>
</span><span class='line'>                                 <span class="nv">file-key</span>,
</span><span class='line'>                                 <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nf">state</span> <span class="nv">file-key</span><span class="p">)</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">rest </span><span class="p">(</span><span class="nb">rest </span><span class="nv">code</span><span class="p">)))))</span>
</span><span class='line'>                          <span class="p">(</span><span class="nb">drop </span><span class="mi">3</span> <span class="nv">code</span><span class="p">))))</span>
</span><span class='line'>      <span class="nv">state</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>

<p>Now, that&#39;s a hack. It&#39;s a bootstrap; I fiddled with it until it worked. It is perhaps more readable than a more elegant version, if you have, like most of us, a background or ongoing investment in imperative style. The principle is ruthless pruning and minimal intelligence. We aren&#39;t touching it further, though we use it as a spring-off point for migraine, the next step in the process.</p>

<p>Migraine because it actually gives birth to Athena. Named in honor of whichever poor sufferer dreamed that mythos up. </p>

<p>So we move the latest athena.md into the project directory, load up the REPL and sure enough, it&#39;s all in there. Now we just have to <code>spit</code> it out. To do it right, we&#39;d have kept some exact record of our file name so we could put it into a new directory of the same form. We&#39;re going to cheat instead; we did the hard part, and want to keep it readable since we don&#39;t have macros with which to bury the boring parts.</p>

<p>So here&#39;s our last trick:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">zeus-map</span> <span class="p">(</span><span class="nf">weave-zeus</span> <span class="p">{}</span> <span class="nv">flat-athena</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">spit</span> <span class="s">&quot;migraine/zeus.grammar&quot;</span>  <span class="p">(</span><span class="ss">:zeus.grammar</span> <span class="nv">zeus-map</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">spit</span> <span class="s">&quot;migraine/core-test.clj&quot;</span> <span class="p">(</span><span class="ss">:core_test.clj</span> <span class="nv">zeus-map</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">spit</span> <span class="s">&quot;migraine/core.clj&quot;</span>      <span class="p">(</span><span class="ss">:core.clj</span> <span class="nv">zeus-map</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>

<p>That&#39;s it! The structure of the migraine directory is flat, not the structure leiningen requires, and there are some extra newlines in the source, but I don&#39;t care and neither should you. It&#39;s officially close enough for government work. In our next chapter, we will undergo the formality of writing a test and demonstrating that Migraine&#39;s markdown contains Athena alpha, which will be a part of Athena herself. </p>

<p>Migraine, the next chapter in this adventure, will add some actual capabilities. Migraine is just Zeus with an extra headache: instead of producing himself, he has to produce Athena, which is a more challenging software to write.   </p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/04/progressive-refinement-in-gll/">Progressive Refinement in GLL</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-04T14:24:00-07:00" pubdate data-updated="true">Aug 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The <a href="http://dotat.at/tmp/gll.pdf">GLL Algorithm</a> is one of those core concepts that can change how we do computation. It&#39;s phenomenally powerful. I believe we&#39;re just starting to see what it&#39;s capable of.</p>

<p>I plan to implement GLL, as soon as some of the support work is done. It&#39;s going to be a somewhat leisurely task. I&#39;m taking a lot of notes. Currently, I&#39;m using <a href="https://github.com/Engelberg/instaparse">Instaparse</a> to play around with the algorithm.</p>

<p>It&#39;s fantastic stuff, much more flexible as an idiom than, say, ANTLR. It is also much easier to write yourself into an exponential corner, and I find myself abusing regular expressions somewhat rather than torturing the grammar in other ways. </p>

<p>I think this is a consequence of GLL&#39;s strengths, which allow it to parse out well over data that is already in a nested structure. Using it for a shallower kind of pattern matching kills performance even in parallel execution, because at any point in matching a long string of related structures, it could encounter a context that would kill the whole chain of inquiry. If there is any possibility of ambiguous matching, this explodes even faster. </p>

<p>An example of this kind of use is parsing a bunch of sentences and paragraphs into text, which is words and whitespace. Except if you encounter a special character you have to switch context completely; this last requirement makes most natural ways of writing the grammar fail. </p>

<p>An alternative would be progressive refinement. In Instaparse, the latest definition of a rule is used, and all earlier rules are ignored. My proposal, which I intend to use in my own work, is that multiple definitions of the same rule are tried sequentially against the data, after a successful parse.</p>

<p>This would damage the arbitrarily-ordered nature of Instaparse grammars, in a sense. Instaparse still has to decide what to do with multiple definitions, and currently uses the last one provided. </p>

<p>This would just formalize something one can already do with Instaparse, which is to parse a string, flatten the area of interest back into a string, and re-parse that string into a new rule. Substitute your new parse for the old one (this is very easy), and you&#39;ve done it.</p>

<p>Automating that into the grammar would allow one to grab large globs of identical data, switching context when necessary, then parse that data into shape in smaller pieces that don&#39;t have to worry about context boundaries. </p>

<p>It&#39;s a straightforward adaptation, being properly speaking a composition of the same function, <code>insta/parse grammar</code>, over a subset of the data returned by the first call. </p>

<h2 id="toc_7">Automated profiling</h2>

<p>One neat thing about grammars is that you can run them backwards to generate compliant gibberish. As you&#39;d expect, given the vast difference in magnitude between the set of valid input of a given length and the set of all input of that same length, it is quick to use Markov type rules to generate babble for even an intricate, ambigous grammar that would blow up trying to validate the output.</p>

<p>In fact, that&#39;s the point. One may envision, and I may even write, a tool that uses pseudorandom walks to generate longer and longer streams of valid gibberish, and try them against the grammar, looking for suspicious jumps in speed or number of possible parses. Even a naive tool, running on a remote server, would generate useful information while developing a parser. One may envision the tool dialing in where parses go ambigous, generating input accordingly, and alerting the user, or doing the same for square and cubic factors that show up.</p>

<p>If the validity of the babble is questionable, then one has identified permission within the grammer that one may wish to eliminate. It has potential.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/03/a-tangled-web-we-weave/">A Tangled Web We Weave</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-03T11:13:00-07:00" pubdate data-updated="true">Aug 3<span>rd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www-cs-faculty.stanford.edu/%7Euno/lp.html">Literate Programming</a> is one of those paradigms whose fate is continual reinvention. I&#39;ve been noticing that my software projects start as Markdown. It stands to reason that they should end up as Markdown as well.</p>

<p><a href="https://help.github.com/articles/github-flavored-markdown">Git Flavored Markdown</a>, in particular, is crying out for a literate, multi-model programming system. The mechanism of named fenced code blocks lets one put multiple languages in a single file, and they will already be syntax highlighted according to the named language. </p>

<p>As literate programming is for the ages, we shall call our system <a href="README.md">Marmion</a>. The weaver shall be known as <a href="athena.md">Athena</a>; the tangler, <a href="">Arachne</a>.</p>

<p>If at all possible, we don&#39;t want to touch GFM itself. Therefore, here are some principles:</p>

<ul>
<li><p>Code in fenced code blocks is extracted, macro-expanded, and executed in whatever ways are appropriate.</p></li>
<li><p>Macros must employ patterns not used in a given language; therefore, we must be able to define those patterns.</p></li>
<li><p>All configuration happens in special code blocks, called <code>```config</code>:</p></li>
</ul>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">{</span> <span class="ss">:name</span> <span class="s">&quot;A config file&quot;</span>,
</span><span class='line'>  <span class="ss">:format</span> <span class="ss">:edn</span>
</span><span class='line'>  <span class="ss">:magic-number</span> <span class="mi">42</span> <span class="p">}</span> <span class="c1">;this is actually tagged ```clojure</span>
</span></code></pre></td></tr></table></div></figure>

<ul>
<li><p>Code in regular unfenced code blocks is not included in the weave. Nor are fenced code blocks that aren&#39;t reached from the top macro. The code above, for example, <em>will not</em> be in the finished weave, because it is exemplary.</p></li>
<li><p>All text ends up in the tangle, which is an HTML file. No other tangle format is contemplated. </p></li>
<li><p>If standardized, the tangle format will not be specified, only the markup format and the requirements for the subsequent weave. HTML is a moving target, as is visual display in general. </p></li>
<li><p>The Markdown may be extended, but only in the same way as any other code: by specifying a macro template and expanding it from provided code. It is the macro-expanded Markdown which is tangled and woven.</p></li>
<li><p>Corollary: the Markdown is macro expanded before anything in a code block.  </p></li>
<li><p>Corollary: the Markdown macro will be standard. There should be no reason to include it. Because Clojure is the implementation language, and has a defined reader macro syntax, this is already true of Clojure(Script).</p></li>
<li><p>The weaver should visit all internal links in search of code. Some tag in HTML form should be provided so that fully-marked-up links, so tagged, will also be followed in search of exterior code. </p></li>
<li><p>If exterior code is requested, it is added to the source as a fenced code block. The tangle will preserve the link directly above the code block. Some sensible effort will be made to infer the code format from the file extension. This is to be done before macro expansion, so that if there are macros in the exterior code, they will be expanded.</p></li>
<li><p>We should maintain a set of canonical macro patterns for languages, to encourage mutual compatibility in source and tangled code.</p></li>
<li><p>No mechanism for transclusion on the file level will be provided. The file structure of the Markdown is the file structure of the tangle. Working around this using the tagged-link method will leave a broken link in your tangle.</p></li>
</ul>

<p>This is the sort of project that we can tackle in stages. The most important part is the weaver, because we have a fine tangler in the form of <a href="http://jekyllrb.com/">Jekyll</a>. </p>

<p>This is a job for <a href="http://clojure.org">Clojure</a>. The weaver and perhaps the tangler will be Clojurescript compatible in the narrow sense, but useless unless Instaparse is ported, which seems unlikely, though you never know. </p>

<p>Clojure is chosen for a few reasons. <a href="https://github.com/edn-format/edn">EDN</a>, for one, which will be the format of any <code>```config</code> code block. Also because of <a href="https://github.com/Engelberg/instaparse">Instaparse</a>, for which the usual regular-expression based markup approach is a strict subset of capabilities. It has the best story I&#39;m aware of for setting regular expressions declaratively in a data format, which is exactly how we will provide macros. </p>

<p>To be clear, this will let us syntax highlight a provided macro in a distinctive way, and put things like the colors to use right in the markdown. This is only useful with a completed weaver; Pygments will get the macros wrong but this is a minor stylistic matter which can be corrected by retangling with a better highlighter. </p>

<p>Instaparse is my go-to choice for writing flexible parsers that are meant to be shared, so Clojure it is. I hope Instaparse catches on to the point where it becomes core, and hence worth maintaining separate <code>.clj</code> and <code>.cljs</code> versions. </p>

<p>The first, and most important step, is writing <a href="athena.md">Athena</a>, the weaver. The weaver does the following: finds all the <code>```config</code> code, parses it to configure itself, then goes after the code blocks, and uses the macros and config information to construct the weave. Finally, it calls the trigger file, which must contain everything needed to build the weave into an executable, or whatever the final product is.</p>

<p>The tangler, <a href="">Arachne</a>, should be a <a href="https://github.com/mnemnion/jekyll">fork of Jekyll</a>, with a low surface area of interaction. What I mean by this is that merges between the bases should avoid touching one another&#39;s files wherever possible. The only changes I contemplate personally is to plug-replace the syntax highlighter, for several reasons. </p>

<p>Pygments requires one to write actual code to markup a new format. This is distasteful. Also, we need to markup the macros, which we won&#39;t know until we weave the code. Furthermore, a static syntax highlighter should be based on a powerful parser, not a regular engine janked up with extra Python. </p>

<p>If Marmion becomes popular, someone might want to write advanced capabilities: putting compatible code in a REPL, for example, or linking to one from the code, or linking to the <a href="https://github.com/mnemnion/emojure/blob/master/src/emojure/core.clj#L7">line number</a> in a public Github repository generated by the weaver. The last is particularly powerful. All of this will assuredly be easier with a parser-backed tangler. </p>

<p>This is the only way I have to tackle large problems: recursing through the Big Project until I hit something atomic and critical to further progress. Arc leads to GGG, which will benefit greatly from a literate style, which leads to Marmion. Marmion built, writing GGG in an understandable way becomes possible. </p>

<p>I think I&#39;ve painted myself into a corner, as I can&#39;t think of anything offhand which I need to write in order to write Marmion. </p>

<p>Time to generate more Markdown!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/27/syntax-for-literal-strings/">Syntax for Literal Strings</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-27T10:09:00-07:00" pubdate data-updated="true">Jul 27<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I find it somewhat astonishing that the languages with which I&#39;m familiar still start and end strings with the same character. It is as though we used <code>|</code> for <code>{</code> and <code>}</code> in code blocks and relied on context to figure out if it was <code>begin</code> or <code>end</code>. </p>

<p>Incidentally, it&#39;s quite possible to write a language this way, and an interesting exercise. <code>for | i = 0 ; i &lt; 2 ; i++ || codeBlock |</code> should parse just fine. Heaven help you if you misplace anything. </p>

<p>Check out <a href="https://en.wikipedia.org/wiki/Delimiter#Bracket_delimiters">bracket delimiters</a> on the Wiki. Two of these things are not like the others. Those two are used preponderantly for strings. </p>

<p>It&#39;s clear enough how it happened. A string has an obvious mapping to literary quotation: <code>&quot;That&#39;s what she said!&quot;</code>.  ASCII gives us exactly three options: <code>&#39;</code>, <code>`</code>, and <code>&quot;</code>. <a href="http://c-programming.itags.org/q_c-programming-language_16297.html">It turns out</a> that C was defined using 91 characters, and <code>`</code> was not among them. </p>

<p>Meta enough, I&#39;m writing this in Markdown, and to type <code>`</code>, I must type <code>`` ` ``</code>. I will leave how I typed <code>`` ` ``</code> as an exercise for the reader. </p>

<p>So C chose <code>&quot;</code> for string syntax, and <code>&#39;</code> for characters, and these decisions made sense, somewhere in the mists of time. C also initiated the proud tradition of string escaping, which wasn&#39;t invented to get around the delimiter problem, but which can be used for that purpose in a hacky way. String escaping is so you can say <code>\n</code> and get a newline, the incidental benefit is you can say <code>\&quot;</code> and get a <code>&quot;</code>, hence one may include any character in such a string. Two backslashes is of course <code>\\\\</code>. One gets used to it. </p>

<p>Oh hey, just for fun, why not write a regex that will match such strings? Won&#39;t take you long, I promise. I&#39;ll be right here!</p>

<p>To the point. In typography, we don&#39;t do this. We start quotations with <code>“</code> or <code>‟</code> and end them with <code>”</code>. On the <a href="http://en.wikipedia.org/wiki/%C2%AB">Continent</a>, <code>«</code> and <code>»</code> are used, and this would be my preference as they are much easier to tell apart and don&#39;t have two choices for the opening delimiter. If you follow the link, It turns out they are used both <code>«this way»</code> and <code>»this way«</code> and even <code>»this way»</code> by Finns (<a href="http://en.wikipedia.org/wiki/Finnish_language">of course</a>). We favor the first, because all other brackets in computer programming are inward facing <code>&lt;{[(like so)]}&gt;</code>.</p>

<p>What&#39;s the point? They aren&#39;t on standard keyboards in the US; while any worthwhile editor can get around this, there&#39;s a pain point there. Some people will argue a virtue in using ASCII for source code, and while those people <a href="https://github.com/cgyarvin/urbit">have a point</a>, the ship sailed a long time ago. We use Unicode, and it isn&#39;t going anywhere. </p>

<p>The point is that, without proper left-right matched strings, you cannot literally quote your own source code within your source code. This is damaged, for any language that lets you evaluate at runtime (the interesting ones IOW). If we use <code>«</code> and <code>»</code>, we can use bog-standard reference counting to assure that any properly-balanced literal strings in the source code get quoted. Since in this imaginary syntax a bare <code>»</code> not balanced on the left with a <code>«</code> is a syntax error, any correct program can be embedded. </p>

<p>If, for any reason, you need a bare <code>»</code>, why not use the ISO standard SHA-1 hash of the Unicode value of <code>»</code>? Why not indeed. It then becomes impossible to literally quote that one hash, which is officially the point where it is perverse to pursue the matter further. Concatenate for that one. </p>

<p>To be clear, <code>&quot;</code> for escaped strings is concise and well understood, and with enough convolutions one may write as one pleases. It&#39;s syntax such as <code>&#39;&#39;&#39;</code> for literal strings that grates against my sensibilities. </p>

<p>Clojure has no syntax for literal, multi-line, unescaped strings. That&#39;s too bad; no one does syntax like Rich Hickey, and I suspect that the inadequacy of existing options plays a role here. He may not be willing to go off-keyboard, but I feel that the <code>«</code> and <code>»</code> syntax has a lot to offer. Certainly Europeans would be pleased. </p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/17/homoiconicity-and-data-forms/">Homoiconicity and Data Forms</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-17T14:52:00-07:00" pubdate data-updated="true">Jun 17<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="toc_6">Representation of Data in Structured Programs.</h3>

<p>Today we&#39;re going to discover a programming language. We&#39;re going to start by contemplating the idea of code as data. </p>

<p>LISP, and by the all-caps I mean the original flavours, had two fundamental forms: atoms, and lists. As Lisp grew up, the lists became able to represent any sort of data type, but at the expense of a certain homoiconicity. </p>

<p>That&#39;s a controversial assertion, but hear me out. A list in a Lisp is a bunch of cons cells, it&#39;s a specific data structure used by default to do pretty much anything. Since the first position (first second third) has a function or a macro, you can fake, say a hash, by saying something like (hash a a-prime b b-prime) but here&#39;s the problem: that&#39;s not homoiconic to your data anymore. Not in a way that accords with modern expectations. </p>

<p>Let&#39;s talk about JSON. Now, JSON is homoiconic to your data. <code>{}</code>? Object. <code>[]</code>? List. <code>&quot;&quot;</code>? String. <code>(1-9)(digits*)</code>? Number. And so on. </p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/06/17/homoiconicity-and-data-forms/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/17/an-introduction-to-ent/">An Introduction to Ent</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-17T10:11:00-07:00" pubdate data-updated="true">Jun 17<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ent is a new approach to code creation. It is (will be) an editor and library that works on parse trees, rather than on files, and registers all changes as <a href="http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation">operational transformations</a>. It does so through the medium of familiar code files, but these may be thought of as an interface to the code, and as a product of it, similar to the executable binaries produced by a compiler. </p>

<h3 id="toc_0">Parse Aware Editing of Structured Files</h3>

<p>ent&#39;s major rationale is parse-awareness. It will, in general, not allow you to type invalid code, though this can always be overridden. It will parse your code as you create it, storing the resulting file as a series of operational transformations on the parse tree. As a language is more thoroughly defined within ent, this enables REPL-like instant feedback and sophisticated refactoring. </p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/06/17/an-introduction-to-ent/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/01/24/literal-and-figurative-languages/">Literal and Figurative Languages</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/17/there-is-no-garbage/">There Is No Garbage</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/17/concurrency-is-an-artifact/">Concurrency Is an Artifact</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/12/those-dadgum-adders/">Those Dadgum Adders</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/12/a-simple-closure-in-forth/">A Simple Closure in Forth</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/mnemnion">@mnemnion</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'mnemnion',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Sam Atman -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
